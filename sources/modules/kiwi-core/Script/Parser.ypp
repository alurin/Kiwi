/*
 *******************************************************************************
 *   Copyright (C) 2012 Vasiliy Sheredeko
 *   MIT license. All Rights Reserved.
 *******************************************************************************
 */

%skeleton   "lalr1.cc"
%require    "2.4"
%define parser_class_name   "Parser"
%define namespace           "kiwi::script"
// %define filename_type       "String"
%defines
%locations
%error-verbose
%debug
// %verbose
// %no-lines

%parse-param    { DriverImpl& driver         }
%parse-param    { Lexer& lexer               }

%code requires {
    #include "Driver.hpp"
    #include "CompoundList.hpp"
    #include "kiwi/Script/ExpressionNode.hpp"

    namespace kiwi {
        namespace script {
            class DriverImpl;
            class Lexer;
        }
    }
}


//===----------------------------------------------------------------------===//
// Non-terminals
//===----------------------------------------------------------------------===//

%token              T_EOF           0       "end of stream"

%token              T_SCRIPT_BEGIN          "<%"
%token              T_SCRIPT_PRINT          "<%:"
%token              T_SCRIPT_END            "%>"
%token  <sval>      T_SCRIPT_STRING         "text"
%token              T_SCRIPT_NEWLINE        "end of line"

%token              T_PRINT                 "put"
%token              T_PRINT_NL              "putn"

%token              T_IN                    "in"
%token              T_REF                   "ref"
%token              T_OUT                   "out"
%token              T_DOTS                  "..."

%token              T_INSERT                "=>"
%token              T_SHL                   "<<"
%token              T_SHR                   ">>"
%token              T_OR                    "||"
%token              T_AND                   "&&"
%token              T_EQ                    "=="
%token              T_NE                    "!="
%token              T_GE                    ">="
%token              T_LE                    "<="
%token              T_INC                   "++"
%token              T_DEC                   "--"
%token              T_AADD                  "+="
%token              T_ASUB                  "-="
%token              T_ADIV                  "/="
%token              T_AMUL                  "*="
%token              T_ASHL                  "<<="
%token              T_ASHR                  ">>="
%token              T_AAND                  "&="
%token              T_AOR                   "|="

%token  <sval>      T_IDENTIFIER            "identifier"
%token  <sval>      T_SYMBOL                "symbol"
%token  <sval>      T_VARIABLE              "variable"
%token  <sval>      T_INSTANCE_FIELD        "instance field"
%token  <sval>      T_STATIC_FIELD          "static field"

%token              T_AUTO                  "auto"
%token              T_DECL                  "decl"
%token              T_VOID                  "void"
%token              T_BOOL                  "bool"
%token              T_INT                   "int"
%token              T_CHAR                  "char"
%token              T_STRING                "string"
%token              T_DOUBLE                "double"

%token              T_AS                    "as"
%token              T_IS                    "is"
%token              T_NEW                   "new"
%token              T_IF                    "if"
%token              T_ELSE                  "else"
%token              T_ELSEIF                "elseif"
%token              T_FOR                   "for"
%token              T_FOREACH               "foreach"
%token              T_WHILE                 "while"
%token              T_REPEAT                "repeat"
%token              T_BREAK                 "break"
%token              T_CONTINUE              "continue"
%token              T_RETURN                "return"
%token              T_TRY                   "try"
%token              T_CATCH                 "catch"
%token              T_FINALLY               "finally"
%token              T_THROW                 "throw"

%token              T_NULL                  "null"
%token              T_TRUE                  "true"
%token              T_FALSE                 "false"
%token  <ival>      T_CONST_INTEGER         "integer const"
%token  <cval>      T_CONST_CHAR            "character const"
%token  <sval>      T_CONST_STRING          "string const"

%token              T_NAMESPACE             "namespace"
%token              T_CLASS                 "class"
%token              T_INTERFACE             "interface"
%token              T_ASPECT                "aspect"
%token              T_ENUM                  "enum"
%token              T_DELEGATE              "delegate"
%token              T_MIXIN                 "mixin"
%token              T_FUNCTION              "function"

%token              T_STATIC                "static"
%token              T_ABSTRACT              "abstract"
%token              T_FINAL                 "final"
%token              T_PRIVATE               "private"
%token              T_PROTECTED             "protected"
%token              T_PUBLIC                "public"

%token              T_VAR                   "var"
%token              T_NS_SEPARATOR          "::"

%token              T_BOGUS
//===----------------------------------------------------------------------===//
// Precidence
//===----------------------------------------------------------------------===//

%nonassoc      MEMBER

%left		'=' "+=" "-=" "/=" "*=" "<<=" ">>=" "&=" "|="
%left		"||"
%left		"&&"
%left		'|'
%left		'^'
%left		'&'
%nonassoc       "==" "!="
%nonassoc	'<' '>' "<=" ">="
%left		">>" "<<"
%left		'-' '+'
%left		'*' '/' '%'
%right		UNARY '!'
%right      PRE '.' '[' '('


//===----------------------------------------------------------------------===//
// Union type for terminal & non-terminal values and its destuctors
//===----------------------------------------------------------------------===//

%union {
    //===- Lexer values ---------------------------------------------------===//
    int64_t                                 ival;           ///< Integer constant
    UChar                                   cval;           ///< Text constant
    String*                                 sval;           ///< String constant or identifier

    //===- AST nodes ------------------------------------------------------===//
    StatementNode*                          stmt;           ///< Statement node
    LeftExpressionNode*                     lexpr;          ///< Left expression node
    ExpressionNode*                         rexpr;          ///< Right expression node
}

%destructor {            } <ival> <cval>
%destructor { delete $$; } <*>

//===----------------------------------------------------------------------===//
// Definitions
//===----------------------------------------------------------------------===//

%{
    #include "Driver.hpp"
    #include "Lexer.hpp"
    #define yylex lexer.lex

    #define yyfree(__px1)                               delete __px1; __px1 = 0;
    #define yyfree2(__px1, __px2)                       yyfree(__px1); yyfree(__px2);

    using namespace kiwi;

    /// Combine identificator to full quil
    String* combineIdentificator(String* s1, String* s2);
%}

%initial-action
{
    /// @todo Memory leak posibly??
    Path streamName = driver.getStreamNameUTF8();
    @$.initialize(&streamName);
};

%start start

%%

start
    : namespace_declare T_EOF
    | script_declare T_EOF
    ;

namespace_declare
    : T_NAMESPACE qualified_identificator ';' { yyfree($2); }
    ;

script_declare
    : statements_list script_declare
    |
    ;

%type <stmt> scope_statement;
scope_statement
    : '{'   { driver.pushScope( new ScopeStatementNode(driver.peakScope(), @1) ); }
            statements_list
      '}'   { $$ = driver.popScope(); }
    ;

statements_list
    : statement statements_list     { driver.peakScope()->addStatement($1); }
    |
    ;

%type <stmt> statement;
statement
    : scope_statement               { $$ = $1;                              }
    | expression ';'                { $$ = new ExpressionStatementNode($1); }
    | variable_declare ';'          { $$ = 0;                               }
    | conditional_statement         { $$ = $1;                              }
    ;

%type <stmt> conditional_statement;
conditional_statement
    : T_IF '(' expression ')' statement                   { $$ = new ConditionalStatementNode($3, $5, @1);     }
    | T_IF '(' expression ')' statement T_ELSE statement  { $$ = new ConditionalStatementNode($3, $5, $7, @1); }
    ;

%type <rexpr> expression;
expression
    : left_expression '=' expression { $$ = new AssignmentExpressionNode($1, $3, @$); }

    | '!' expression                 { $$ = new UnaryExpressionNode($2, UnaryExpressionNode::OP_NOT, @$); }
    | '+' expression  %prec UNARY    { $$ = new UnaryExpressionNode($2, UnaryExpressionNode::OP_POS, @$); }
    | '-' expression  %prec UNARY    { $$ = new UnaryExpressionNode($2, UnaryExpressionNode::OP_NEG, @$); }

    | expression '+' expression      { $$ = new BinaryExpressionNode($1, $3, BinaryExpressionNode::OP_ADD, @$); }
    | expression '-' expression      { $$ = new BinaryExpressionNode($1, $3, BinaryExpressionNode::OP_SUB, @$); }
    | expression '*' expression      { $$ = new BinaryExpressionNode($1, $3, BinaryExpressionNode::OP_MUL, @$); }
    | expression '/' expression      { $$ = new BinaryExpressionNode($1, $3, BinaryExpressionNode::OP_DIV, @$); }

    | right_expression               { $$ = $1; }
    ;

variable_declare
    : T_VAR variable_declare_list
    ;

variable_declare_list
    : single_variable_declare ',' variable_declare_list
    | single_variable_declare
    ;

single_variable_declare
    : T_VARIABLE '=' expression     {
                                        driver.declareVariable(*$1, @1);
                                        StatementNode* node = new ExpressionStatementNode($3);
                                        driver.peakScope()->addStatement(node);
                                        yyfree($1);
                                    }
    | T_VARIABLE                    { driver.declareVariable(*$1, @1); yyfree($1); }
    ;

%type <lexpr> left_expression;
left_expression
    : T_VARIABLE                     { $$ = new LeftVariableNode(driver.getVariable(*$1), @1); yyfree($1); }
    ;

%type <rexpr> right_expression;
right_expression
    : T_VARIABLE                     { $$ = new RightVariableNode(driver.getVariable(*$1), @1); yyfree($1); }
    | right_value                    { $$ = $1; }
    ;

%type <rexpr> right_value;
right_value
    : T_CONST_INTEGER   { $$ = new IntegerNode($1, @1);             }
    | T_CONST_CHAR      { $$ = new CharNode($1, @1);                }
    | T_CONST_STRING    { $$ = new StringNode(*$1, @1); yyfree($1); }
    | T_NULL            { $$ = new NullableNode(@1);                }
    | T_TRUE            { $$ = new BooleanNode(true, @1);           }
    | T_FALSE           { $$ = new BooleanNode(false, @1);          }
    ;

///==--------------------------------------------------------------------------------------------------------------==///
///   Fully qualified identifiers
///==--------------------------------------------------------------------------------------------------------------==///

%type <sval> qualified_identificator;
qualified_identificator
    : T_IDENTIFIER qualified_identificator_part                 { $$ = combineIdentificator($1, $2); yyfree($2); }
    ;

%type <sval> qualified_identificator_part;
qualified_identificator_part
    : T_NS_SEPARATOR T_IDENTIFIER qualified_identificator_part  { $$ = combineIdentificator($2, $3); yyfree($3); }
    |                                                           { $$ = NULL; }
    ;

%%

#include "kiwi/Engine.hpp"
#include "kiwi/Host.hpp"
#include "kiwi/IO/Stream.hpp"

using namespace kiwi;
using namespace kiwi::io;
using namespace kiwi::script;

String* combineIdentificator(String* s1, String* s2) {
    KIWI_DEBUG_ASSERT(s1 && "First identificator must not be null");
    if (s2) {
        *s1 = *s1 + "::" + *s2;
    }
    return s1;
}

/**
 *
 * @todo Replace output to exception or e.g.
 */
void Parser::error (const location_type& loc, const std::string& msg) {
    Engine*       engine = driver.getEngine();
    Host*         host   = engine->getHost();
    OutputStream* stream = host->getErrorStream();

    UnicodeString message(msg.c_str());
    stream->write(message.getTerminatedBuffer(), message.length());
    message.releaseBuffer();

    /* driver.error(support::SYNTAX_ERROR) << loc << String(msg.c_str());*/
    //OutputStream stre(driver.getEngine());
    //stre << msg << "\n";
}

Location::Location(const location& loc) {
    m_streamName = loc.begin.filename->c_str();
    //m_begin    = Position(loc.begin.line, loc.begin.column);
    //m_end      = Position(loc.end.line, loc.end.column);
}
